Object  subclass: #FuzzyInterface  instanceVariableNames: 'regeln sets lingvarliste eingang ausgang zwischen gesamtflaeche'  classVariableNames: 'YDisplayScale XDisplayScale Flaechengroesse'  poolDictionaries: '' !!FuzzyInterface class methods! !!FuzzyInterface methods!alleSets    "testphase !!!!!!!!!!!!"    |aset asetliste avar|    avar := lingvarliste at: 'druck'.    asetliste := avar setliste.    asetliste keysDo: [:anset | aset := avar set: anset.                                aset display]!ausgangalle    "Defuzzyfizierung durchführen für Ausgangsvariable. (Nur eine. bei allen    siehe ausgangalle . "    | operator |    "-----Alle Regeln abarbeiten."    "Regelsyntax:('operator'(Eingang_1 ... Eingang_n) Ziel_der_Schlußfolgerung )"    "   z.B.: ('und'(heiss hoch) zu)    "    " -> WENN Temperatur heiss und Druck hoch DANN Ventil zu.   "    " Für jede Regel wird eine Teilfläche der Grsamtfläche hinzugefügt."    regeln do: [:myregel |        operator := myregel at: 1.        operator = 'minimum'            ifTrue: [self und: (myregel at: 2) dann: (myregel at: 3) ].        operator = 'minimumZ'            ifTrue: [self und: (myregel at: 2) dannZ: (myregel at: 3) ].        operator = 'maximum'            ifTrue: [self oder: (myregel at: 2) dann: (myregel at: 3) ].       operator = 'maximumZ'            ifTrue: [self oder: (myregel at: 2) dannZ: (myregel at: 3) ].    ].    "-----deFuzzysifizierung"    "   Für jeden Eintrag in der Liste ausgang wird der Schwerpunkt der Fläche    berechnet. "    ausgang keysDo: [:myausgang | ausgang at: myausgang put: (self deFuzzy: myausgang)].    "Ausgeben des Wertes dessen Namen angegeben wurde."    ^ausgang keysDo: [:myausgang | ausgang at: myausgang].!ausgangInit: aString    "Ausgang in Liste eintragen. Nur die in dieser liste stehenden Variablen    werden defuzzyfiziert."    ausgang isNil        ifTrue: [ausgang := Dictionary new].    ausgang at: aString put: nil!ausgangLesen: aString    "Defuzzyfizierung durchführen für Ausgangsvariable. (Nur eine. bei allen    siehe ausgangalle: . "    | operator |    "-----Alle Regeln abarbeiten."    "Regelsyntax:('operator'(Eingang_1 ... Eingang_n) Ziel_der_Schlußfolgerung )"    "   z.B.: ('und'(heiss hoch) zu)    "    " -> WENN Temperatur heiss und Druck hoch DANN Ventil zu.   "    " Für jede Regel wird eine Teilfläche der Grsamtfläche hinzugefügt."    regeln do: [:myregel |        operator := myregel at: 1.        operator = 'minimum'            ifTrue: [self und: (myregel at: 2) dann: (myregel at: 3) ].        operator = 'minimumZ'            ifTrue: [self und: (myregel at: 2) dannZ: (myregel at: 3) ].        operator = 'maximum'            ifTrue: [self oder: (myregel at: 2) dann: (myregel at: 3) ].        operator = 'maximumZ'            ifTrue: [self oder: (myregel at: 2) dannZ: (myregel at: 3) ].    ].    "-----deFuzzysifizierung"    "   Für jeden Eintrag in der Liste ausgang wird der Schwerpunkt der Fläche    berechnet. "    ausgang keysDo: [:myausgang | ausgang at: myausgang put: (self deFuzzy: myausgang)].    "Ausgeben des Wertes dessen Namen angegeben wurde."    ^ausgang at: aString.!clickinDisplay    "comment"!deFuzzy: aString    "startet die Defuzzyfizierung."    | myLingVar ganzeFlaeche halbeFlaeche suchhalbeFlaeche mylauf bereich|    myLingVar := self var: aString.    ganzeFlaeche := 0.    suchhalbeFlaeche := 0.    mylauf := 0.    1 to: Flaechengroesse do: [:lauf | ganzeFlaeche := ganzeFlaeche +  (myLingVar deFuzzyFlaeche at: lauf)].    halbeFlaeche := ganzeFlaeche / 2.    "-----Index des Schwerpunktes im Flächenarray ermitteln."    [suchhalbeFlaeche <= halbeFlaeche]        whileTrue: [mylauf := mylauf +1.                    suchhalbeFlaeche := suchhalbeFlaeche +  (myLingVar deFuzzyFlaeche at: mylauf).        ].    "Fläche löschen."    1 to: Flaechengroesse do: [:lauf | myLingVar deFuzzyFlaeche at: lauf put: 0].    "-----Aus Index Ausgangswert berechnen und ausgeben."    bereich := (-1 * myLingVar xmin  ) + myLingVar xmax abs.    ^((mylauf - 1) * bereich / (Flaechengroesse - 1)) + myLingVar xmin!deFuzzyDelete: aString    "Löscht die Defuzzyfizierungfläche."    | myLingVar|    myLingVar := self var: aString.    1 to: Flaechengroesse do: [:lauf | myLingVar deFuzzyFlaeche at: lauf put: 0]!displayMenu    "Answer the menu for the receiver."    ^ (Menu        labels: 'Alle Sets\Ein Set'                    breakLinesAtBackSlashes        lines: #(1)        selectors: #(alleSets einSet))        title: 'Setdisplay'!eingang: aString setzen: aNumber    "Trägt den Wert einer Linguistischen Variable in die Meßwertliste    eingang ein. aString sollte dem varname entsprechen."    |lingvar|    eingang isNil        ifTrue: [eingang := Dictionary new].    lingvar := lingvarliste at: aString.             "Das Object zum Namen in aString wird ermittelt."    lingvar setliste do: [:set | set eingangswert: aNumber]."Der Eingangsw. wird in das Set geschrieben."    eingang at: aString put: aNumber!einSet    "zeichnet das angegebene Set."    |aset avar|    avar := lingvarliste at: 'druck'.    aset := avar set: 'mittel'.    aset display!flaechengroesse: ainteger    "stellt die Genauigkeit der Defuzzyfizierung ein."    Flaechengroesse := ainteger!lingvar: astring    "zeigt die Linguistische Variable astring"!lingvarliste    "comment"    ^lingvarliste!neueLingVar: aObject    " legt die variable in der lingvarliste ab."    | avarname avar|    lingvarliste isNil        ifTrue: [lingvarliste := Dictionary new].    avar        := aObject.    avarname    := avar varname.    lingvarliste at: avarname put: avar.!neueRegel: aArray    "trägt eine neue regel in die regelliste regeln ein."    regeln isNil        ifTrue: [regeln := Set new].    regeln add: aArray.!neueregel: aBlock    "trägt eine neue regel in die regelliste regeln ein."    regeln isNil        iftrue: [regeln := Set new].    regeln add: aBlock.!neueRegel: aString mit: aArray dann: aObject    "trägt eine neue regel in die regelliste regeln ein."    |eineRegel|    regeln isNil        ifTrue: [regeln := Array new].    eineRegel := Array new.    eineRegel with: aString with: aArray with: aObject.    regeln add: aArray.!oder: aArray dann: aObject    "Oder-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top z|    "aArray enthält alle Sets die durch den oder-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at: (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top > element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    self teilFlaeche: aObject product: ergebnis!oder: aArray dannZ: aObject    "Oder-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top z|    "aArray enthält alle Sets die durch den oder-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at: (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top > element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    z := aObject.    z := ergebnis!teilFlaeche: aObject product: aNumber    "Trägt eine teilfläche in die gesamtflaeche zur Schwerpunktbestimmung ein."    | neueflaeche flaechengroesse flaeche xUmrechnung bereich productdegree myLingVar|    neueflaeche := OrderedCollection new.    Flaechengroesse timesRepeat: [neueflaeche add: 0].    myLingVar := self varObjectZuSet: aObject.    myLingVar deFuzzyFlaeche isNil        ifTrue: [ myLingVar deFuzzyFlaeche: neueflaeche].    "Umrechnung Wertebereich auf Flaechengroesse."    bereich := (-1 * aObject xmin  ) + aObject xmax abs.    1 to: Flaechengroesse do: [:lauf |productdegree := aNumber * (aObject degree: (((lauf - 1) * bereich / (Flaechengroesse - 1)) + aObject xmin) ).                                productdegree > (myLingVar deFuzzyFlaeche at: lauf)                                    ifTrue: [myLingVar deFuzzyFlaeche at: lauf put: productdegree].                                 ]!und: aArray dann: aObject    "Und-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top|    "aArray enthält alle Sets die durch den Und-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."                                                                              "setname"    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at:  (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    "In dem Array alle stehen Zugehörigkeitswerte aller Sets die verknüpft werden."    "Und-Verknüpfung. --minimum-- "    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top < element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    self teilFlaeche: aObject product: ergebnis!und: aArray dannZ: aObject   "Und-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top z|    "aArray enthält alle Sets die durch den Und-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."                                                                              "setname"    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at:  (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    "In dem Array alle stehen Zugehörigkeitswerte aller Sets die verknüpft werden."    "Und-Verknüpfung. --minimum-- "    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top < element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    z := aObject.    z := ergebnis!var: aString    "liefert das Setobject bei Angabe des namens."    ^lingvarliste at: aString!varObjectZuSet: aObject    "Antwortet mit der Instance einer Ling.Var. des fuzzyset-Objects aObject."    | myvar |    lingvarliste keysDo: [ :aVarname |        myvar := self var: aVarname.        (myvar setliste includes: aObject)            ifTrue: [^myvar].    ].!varZuSet: aObject    "Antwortet mit dem varnamen einer Ling.Var. des fuzzyset-Objects aObject."    | myvar |    lingvarliste keysDo: [ :aVarname |        myvar := self var: aVarname.        (myvar setliste includes: aObject )            ifTrue: [^aVarname].    ].! !