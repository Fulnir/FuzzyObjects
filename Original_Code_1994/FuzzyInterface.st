FuzzyObjects                  name: #FuzzyInterface           superclass: Environment@#Object           properties: 0x1000             category: #'Kernel-Object'   classVariableNames: nilinstanceVariableNames: {'regeln'. 'sets'. 'lingvarliste'. 'eingang'. 'ausgang'. 'zwischen'. 'gesamtflaeche'}  sharedVariableNames: #(Flaechengroesse YDisplayScale XDisplayScale)           namespaces: nil   structureTemplates: nil   defaultStorageSize: 0!FuzzyObjects@#FuzzyInterface compileMethodSource: ('alleSets    "testphase !!!!!!!!!!!!"    |aset asetliste avar|    avar := lingvarliste at: ''druck''.    asetliste := avar setliste.    asetliste keysDo: [:anset | aset := avar set: anset.                                aset display]')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #alleSets) description: ('testphase !!!!!!!!!!!!').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('ausgangInit: aString    "Ausgang in Liste eintragen. Nur die in dieser liste stehenden Variablen    werden defuzzyfiziert."    ausgang isNil        ifTrue: [ausgang := Dictionary new].    ausgang at: aString put: nil')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #ausgangInit:) description: ('Ausgang in Liste eintragen. Nur die in dieser liste stehenden Variablen werden defuzzyfiziert.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('clickinDisplay    "comment"')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #clickinDisplay) protocolCategory: 'identity'.!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #clickinDisplay) description: ('comment').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('deFuzzy: aString    "startet die Defuzzyfizierung."    | myLingVar ganzeFlaeche halbeFlaeche suchhalbeFlaeche mylauf bereich|    myLingVar := self var: aString.    ganzeFlaeche := 0.    suchhalbeFlaeche := 0.    mylauf := 0.    1 to: Flaechengroesse do: [:lauf | ganzeFlaeche := ganzeFlaeche +  (myLingVar deFuzzyFlaeche at: lauf)].    halbeFlaeche := ganzeFlaeche / 2.    "-----Index des Schwerpunktes im Flächenarray ermitteln."    [suchhalbeFlaeche <= halbeFlaeche]        whileTrue: [mylauf := mylauf +1.                    suchhalbeFlaeche := suchhalbeFlaeche +  (myLingVar deFuzzyFlaeche at: mylauf).        ].    "Fläche löschen."    1 to: Flaechengroesse do: [:lauf | myLingVar deFuzzyFlaeche at: lauf put: 0].    "-----Aus Index Ausgangswert berechnen und ausgeben."    bereich := (-1 * myLingVar xmin  ) + myLingVar xmax abs.    ^((mylauf - 1) * bereich / (Flaechengroesse - 1)) + myLingVar xmin')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #deFuzzy:) description: ('startet die Defuzzyfizierung.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('deFuzzyDelete: aString    "Löscht die Defuzzyfizierungfläche."    | myLingVar|    myLingVar := self var: aString.    1 to: Flaechengroesse do: [:lauf | myLingVar deFuzzyFlaeche at: lauf put: 0]')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #deFuzzyDelete:) description: ('Löscht die Defuzzyfizierungfläche.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('eingang: aString setzen: aNumber    "Trägt den Wert einer Linguistischen Variable in die Meßwertliste    eingang ein. aString sollte dem varname entsprechen."    |lingvar|    eingang isNil        ifTrue: [eingang := Dictionary new].    lingvar := lingvarliste at: aString.             "Das Object zum Namen in aString wird ermittelt."    lingvar setliste do: [:set | set eingangswert: aNumber]."Der Eingangsw. wird in das Set geschrieben."    eingang at: aString put: aNumber')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #eingang:setzen:) description: ('Trägt den Wert einer Linguistischen Variable in die Meßwertliste eingang ein. aString sollte dem varname entsprechen.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('einSet    "zeichnet das angegebene Set."    |aset avar|    avar := lingvarliste at: ''druck''.    aset := avar set: ''mittel''.    aset display')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #einSet) description: ('zeichnet das angegebene Set.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('flaechengroesse: ainteger    "stellt die Genauigkeit der Defuzzyfizierung ein."    Flaechengroesse := ainteger')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #flaechengroesse:) description: ('stellt die Genauigkeit der Defuzzyfizierung ein.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('lingvar: astring    "zeigt die Linguistische Variable astring"')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #lingvar:) protocolCategory: 'identity'.!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #lingvar:) description: ('zeigt die Linguistische Variable astring').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('lingvarliste    "comment"    ^lingvarliste')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #lingvarliste) protocolCategory: 'getter'.!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #lingvarliste) description: ('comment').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('neueLingVar: aObject    " legt die variable in der lingvarliste ab."    | avarname avar|    lingvarliste isNil        ifTrue: [lingvarliste := Dictionary new].    avar        := aObject.    avarname    := avar varname.    lingvarliste at: avarname put: avar.')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #neueLingVar:) description: ('legt die variable in der lingvarliste ab.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('neueRegel: aArray    "trägt eine neue regel in die regelliste regeln ein."    regeln isNil        ifTrue: [regeln := Set new].    regeln add: aArray.')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #neueRegel:) description: ('trägt eine neue regel in die regelliste regeln ein.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('neueregel: aBlock    "trägt eine neue regel in die regelliste regeln ein."    regeln isNil        iftrue: [regeln := Set new].    regeln add: aBlock.')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #neueregel:) description: ('trägt eine neue regel in die regelliste regeln ein.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('neueRegel: aString mit: aArray dann: aObject    "trägt eine neue regel in die regelliste regeln ein."    |eineRegel|    regeln isNil        ifTrue: [regeln := Array new].    eineRegel := Array new.    eineRegel with: aString with: aArray with: aObject.    regeln add: aArray.')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #neueRegel:mit:dann:) description: ('trägt eine neue regel in die regelliste regeln ein.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('oder: aArray dann: aObject    "Oder-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top z|    "aArray enthält alle Sets die durch den oder-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at: (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top > element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    self teilFlaeche: aObject product: ergebnis')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #oder:dann:) description: ('Oder-Operator. Ergebnis in Gesamtfläche eintragen.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('oder: aArray dannZ: aObject    "Oder-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top z|    "aArray enthält alle Sets die durch den oder-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at: (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top > element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    z := aObject.    z := ergebnis')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #oder:dannZ:) description: ('Oder-Operator. Ergebnis in Gesamtfläche eintragen.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('teilFlaeche: aObject product: aNumber    "Trägt eine teilfläche in die gesamtflaeche zur Schwerpunktbestimmung ein."    | neueflaeche flaechengroesse flaeche xUmrechnung bereich productdegree myLingVar|    neueflaeche := OrderedCollection new.    Flaechengroesse timesRepeat: [neueflaeche add: 0].    myLingVar := self varObjectZuSet: aObject.    myLingVar deFuzzyFlaeche isNil        ifTrue: [ myLingVar deFuzzyFlaeche: neueflaeche].    "Umrechnung Wertebereich auf Flaechengroesse."    bereich := (-1 * aObject xmin  ) + aObject xmax abs.    1 to: Flaechengroesse do: [:lauf |productdegree := aNumber * (aObject degree: (((lauf - 1) * bereich / (Flaechengroesse - 1)) + aObject xmin) ).                                productdegree > (myLingVar deFuzzyFlaeche at: lauf)                                    ifTrue: [myLingVar deFuzzyFlaeche at: lauf put: productdegree].                                 ]')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #teilFlaeche:product:) description: ('Trägt eine teilfläche in die gesamtflaeche zur Schwerpunktbestimmung ein.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('und: aArray dann: aObject    "Und-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top|    "aArray enthält alle Sets die durch den Und-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."                                                                              "setname"    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at:  (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    "In dem Array alle stehen Zugehörigkeitswerte aller Sets die verknüpft werden."    "Und-Verknüpfung. --minimum-- "    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top < element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    self teilFlaeche: aObject product: ergebnis')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #und:dann:) description: ('Und-Operator. Ergebnis in Gesamtfläche eintragen.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('und: aArray dannZ: aObject   "Und-Operator. Ergebnis in Gesamtfläche eintragen."    | einer alle ergebnis top z|    "aArray enthält alle Sets die durch den Und-Operator verknüpft werden.    do: bewirkt, daß mit jedem Set als Parameter der Block ausgeführt wird."                                                                              "setname"    aArray do: [:aFuzzySet | einer := aFuzzySet degree: ( eingang at:  (self varZuSet: aFuzzySet)).                    alle isNil                        ifTrue: [alle := Set with: einer]                        ifFalse: [alle add: einer]                    ].    "In dem Array alle stehen Zugehörigkeitswerte aller Sets die verknüpft werden."    "Und-Verknüpfung. --minimum-- "    alle do: [:element | top isNil                                ifTrue: [top := element]                                ifFalse: [top < element                                            ifFalse: [top := element].                                ].                ].    ergebnis := top.    z := aObject.    z := ergebnis')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #und:dannZ:) description: ('Und-Operator. Ergebnis in Gesamtfläche eintragen.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('var: aString    "liefert das Setobject bei Angabe des namens."    ^lingvarliste at: aString')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #var:) description: ('liefert das Setobject bei Angabe des namens.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('varObjectZuSet: aObject    "Antwortet mit der Instance einer Ling.Var. des fuzzyset-Objects aObject."    | myvar |    lingvarliste keysDo: [ :aVarname |        myvar := self var: aVarname.        (myvar setliste includes: aObject)            ifTrue: [^myvar].    ].')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #varObjectZuSet:) description: ('Antwortet mit der Instance einer Ling.Var. des fuzzyset-Objects aObject.').!FuzzyObjects@#FuzzyInterface compileMethodSource: ('varZuSet: aObject    "Antwortet mit dem varnamen einer Ling.Var. des fuzzyset-Objects aObject."    | myvar |    lingvarliste keysDo: [ :aVarname |        myvar := self var: aVarname.        (myvar setliste includes: aObject )            ifTrue: [^aVarname].    ].')!(FuzzyObjects@#FuzzyInterface instanceMethodFor: #varZuSet:) description: ('Antwortet mit dem varnamen einer Ling.Var. des fuzzyset-Objects aObject.').!